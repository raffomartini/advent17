'''
--- Day 21: Fractal Art ---
You find a program trying to generate some art. It uses a strange process that involves repeatedly enhancing the detail of an image through a set of rules.

The image consists of a two-dimensional square grid of pixels that are either on (#) or off (.). The program always begins with this pattern:

.#.
..#
###
Because the pattern is both 3 pixels wide and 3 pixels tall, it is said to have a size of 3.

Then, the program repeats the following process:

If the size is evenly divisible by 2, break the pixels up into 2x2 squares, and convert each 2x2 square into a 3x3 square by following the corresponding enhancement rule.
Otherwise, the size is evenly divisible by 3; break the pixels up into 3x3 squares, and convert each 3x3 square into a 4x4 square by following the corresponding enhancement rule.
Because each square of pixels is replaced by a larger one, the image gains pixels and so its size increases.

The artist's book of enhancement rules is nearby (your puzzle input); however, it seems to be missing rules. The artist explains that sometimes, one must rotate or flip the input pattern to find a match. (Never rotate or flip the output pattern, though.) Each pattern is written concisely: rows are listed as single units, ordered top-down, and separated by slashes. For example, the following rules correspond to the adjacent patterns:

../.#  =  ..
          .#

                .#.
.#./..#/###  =  ..#
                ###

                        #..#
#..#/..../#..#/.##.  =  ....
                        #..#
                        .##.
When searching for a rule to use, rotate and flip the pattern as necessary. For example, all of the following patterns match the same rule:

.#.   .#.   #..   ###
..#   #..   #.#   ..#
###   ###   ##.   .#.
Suppose the book contained the following two rules:

../.# => ##./#../...
.#./..#/### => #..#/..../..../#..#
As before, the program begins with this pattern:

.#.
..#
###
The size of the grid (3) is not divisible by 2, but it is divisible by 3. It divides evenly into a single square; the square matches the second rule, which produces:

#..#
....
....
#..#
The size of this enhanced grid (4) is evenly divisible by 2, so that rule is used. It divides evenly into four squares:

#.|.#
..|..
--+--
..|..
#.|.#
Each of these squares matches the same rule (../.# => ##./#../...), three of which require some flipping and rotation to line up with the rule. The output for the rule is the same in all four cases:

##.|##.
#..|#..
...|...
---+---
##.|##.
#..|#..
...|...
Finally, the squares are joined into a new grid:

##.##.
#..#..
......
##.##.
#..#..
......
Thus, after 2 iterations, the grid contains 12 pixels that are on.

How many pixels stay on after 5 iterations?
'''

import numpy as np
import math
FILE = 'input21.txt'

INIT = '.#./..#/###'
DEBUG = False

def load(file=FILE):
    '''
    returns: rules
    '''
    with open(file) as f:
        in_ = f.read().splitlines()
    rules = in_ |> map$(.split(' => ')) |> dict
    return rules

def str2table(str_):
    return str_.split('/') |> fmap$(list)

def rotate_r(original):
    return original[::-1] |*> zip |> tuple

def rotate_180(original):
    return original |> rotate_r |> rotate_r

def rotate_l(original):
    return original |> rotate_r |> rotate_r |> rotate_r

def flip_o(original):
    return original[::-1]

def flip_v(original):
    return original |> map$((l) -> l|> reversed |> list) |> list

def table2str(table):
    return table |> map$(''.join) |> '/'.join

def fractalize(table,rules):
    transformations1 = ( lambda x: x, rotate_l, rotate_180, rotate_r)
    transformations2 = ( lambda x: x, flip_v, flip_o)
    for f in transformations1:
        for g in transformations2:
            s_table = table |> f |> g |> table2str
            # print(s_table)
            if s_table in rules:
                'match: {}'.format(s_table) |> print
                return rules[s_table] |> str2table
    else:
        assert False


def split(table):
    len_ = len(table)
    table = np.array(table)
    if len_ % 2 == 0:
        k = 2
    elif len_ % 3 == 0:
        k = 3
    else:
        assert False
    return [table[k*i:k*i+k,k*j:k*j+k].tolist() for i in range(len_//k) for j in range(len_//k)]

def rebuild(splitted):
    n_split = len(splitted)
    side = int(math.sqrt(len(splitted)))
    smallsize = len(splitted[0])
    size = smallsize * side
    if DEBUG:
        'side: {}, size:{}'.format(side, size) |> print
    table = [[] for i in range(size)]
    for i in range(size):
        # print(i)
        for j in range(side):
            # print(i,j,i//smallsize*smallsize+j,i%smallsize)
            table[i] += splitted[i//smallsize*side+j][i%smallsize]
    return table

def count_pixels(table):

    def accumulate_pixel(acc,pixel):
        return acc + (1 if pixel =='#' else 0)

    return table |> map$(reduce$(accumulate_pixel,?,0)) |> sum 



def part1(file=FILE):
    rules = load(file)
    table = INIT |> str2table
    for i in range(5):
        table = table |> split |> fmap$(fractalize$(?,rules)) |> rebuild
    return table |> count_pixels

def part2(file=FILE):
    rules = load(file)
    table = INIT |> str2table
    for i in range(18):
        table = table |> split |> fmap$(fractalize$(?,rules)) |> rebuild
    return table |> count_pixels

'&^'*55 |> print
part1() |> print
'&^'*55 |> print
part2() |> print









